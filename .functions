#!/usr/bin/env bash

# Create a new directory and enter it
function md() {
	mkdir -p "$@" && $(cd "$@" || exit)
}

# cd into whatever is the forefront Finder window.
cdf() {  # short for cdfinder
	cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# find shorthand
function f() {
	find . -name "$1"
}

# git log with per-commit cmd-clickable GitHub URLs (iTerm)
function gf() {
	local remote="$(git remote -v | awk '/^origin.*\(push\)$/ {print $2}')"
	[[ "$remote" ]] || return
	local user_repo="$(echo "$remote" | perl -pe 's/.*://;s/\.git$//')"
	git log $* --name-status --color | awk "$(cat <<AWK
		/^.*commit [0-9a-f]{40}/ {sha=substr(\$2,1,7)}
		/^[MA]\t/ {printf "%s\thttps://github.com/$user_repo/blob/%s/%s\n", \$1, sha, \$2; next}
		/.*/ {print \$0}
AWK
	)" | less -F
}

# Copy w/ progress
cp_p () {
	rsync -WavP --human-readable --progress $1 $2
}

sshSecureKeygen() {
	ssh-keygen -b 4096 -f ~/.ssh/id_rsa_$1 -C sam@$1_4096
}

# Syntax-highlight JSON strings or files
function json() {
	if [ -p /dev/stdin ]; then
		# piping, e.g. `echo '{"foo":42}' | json`
		python -mjson.tool | pygmentize -l javascript
	else
		# e.g. `json '{"foo":42}'`
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	fi
}

# take this repo and copy it to somewhere else minus the .git stuff.
function gitexport(){
	mkdir -p "$1"
	git archive master | tar -x -C "$1"
}

# get gzipped size
function gz() {
	echo "orig size    (bytes): "
	cat "$1" | wc -c
	echo "gzipped size (bytes): "
	gzip -c "$1" | wc -c
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
	if [ -f "$1" ] ; then
		local filename=$(basename "$1")
		local foldername="${filename%%.*}"
		local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
		local didfolderexist=false
		if [ -d "$foldername" ]; then
			didfolderexist=true
			read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
			echo
			if [[ $REPLY =~ ^[Nn]$ ]]; then
				return
			fi
		fi
		mkdir -p "$foldername" && cd "$foldername"
		case $1 in
			*.tar.bz2) tar xjf "$fullpath" ;;
			*.tar.gz) tar xzf "$fullpath" ;;
			*.tar.xz) tar Jxvf "$fullpath" ;;
			*.tar.Z) tar xzf "$fullpath" ;;
			*.tar) tar xf "$fullpath" ;;
			*.taz) tar xzf "$fullpath" ;;
			*.tb2) tar xjf "$fullpath" ;;
			*.tbz) tar xjf "$fullpath" ;;
			*.tbz2) tar xjf "$fullpath" ;;
			*.tgz) tar xzf "$fullpath" ;;
			*.txz) tar Jxvf "$fullpath" ;;
			*.zip) unzip "$fullpath" ;;
			*) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

# packs $2-$n into $1 depending on $1's extension.  add more file types as needed
function pack() {
	if [ $# -lt 2 ] ; then
		echo -e "\npack() usage:"
		echo -e "\tpack archive_file_name file1 file2 ... fileN"
		echo -e "\tcreates archive of files 1-N\n"
	else
		DEST=$1
		shift

		case $DEST in
			*.tar.bz2) tar -cvjf $DEST "$@" ;;
			*.tar.gz) tar -cvzf $DEST "$@" ;;
			*.zip) zip -r $DEST "$@" ;;
			*.xpi) zip -r $DEST "$@" ;;
			*) echo "Unknown file type - $DEST" ;;
		esac
	fi
}

# change the version of java being used on the fly
function setjdk() {
	export JAVA_HOME=$(/usr/libexec/java_home -v $1)
}

function update() {
	sudo softwareupdate -i -a

	# Homebrew
	brew update
	brew upgrade
	brew cleanup
	brew cask cleanup

	# Ruby gems
	gem cleanup
	gem update
}

function chef_json() {
	chef exec ruby -e 'p ARGF.read' "$1"
}

function cleanup_berkshelf() {
	rm -rf "$HOME/.berkshelf/cookbooks"
	rm -rf "$HOME/.berkshelf/.cache"
}

function terraform-chef-destroy() {
	grep '"name":' "terraform.tfstate" | awk '{print $2}' | sort | uniq | xargs -I {} sh -c "knife node delete -y {}; knife client delete -y {} || true"
	terraform destroy
}

function berksderp() {
	vagrant destroy -f
	rm Berksfile.lock
	rm -rf .vagrant/
	cleanup_berkshelf
}

function vagrant-global-destroy() {
	vagrant global-status | awk '/running/{print $1}' | xargs -n 1 -- vagrant destroy -f
	cleanup_berkshelf
	vagrant global-status --prune
}

function vagrant-rage() {
	berksderp
	vagrant up
}

function vagrant-box-update-all() {
	# Find all boxes which have updates
	AVAILABLE_UPDATES=`vagrant box outdated --global | grep outdated | tr -d "*'" | cut -d ' ' -f 2`

	if [ ! ${#AVAILABLE_UPDATES[@]} -eq 0 ]; then
	  for box in $AVAILABLE_UPDATES ; do

	    echo "Found an update for $box"

	    # Find all current versions
	    VERSIONS=`vagrant box list | grep $box | cut -d ',' -f 2 | tr -d ' )'`

	    # Add latest version
	    vagrant box add --clean $box

	    # Remove all old versions
	    for version in $VERSIONS ; do
	      vagrant box remove $box -f --box-version=$version
	    done

	  done

	  echo "All boxes are now up to date!"

	else

	  echo "All boxes are already up to date!"

	fi

	vagrant box outdated --global
}
