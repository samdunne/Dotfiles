# Create a new directory and enter it
function md() {
	mkdir -p "$@" && cd "$@"
}

# cd into whatever is the forefront Finder window.
cdf() {  # short for cdfinder
	cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# find shorthand
function f() {
		find . -name "$1"
}

# git log with per-commit cmd-clickable GitHub URLs (iTerm)
function gf() {
	local remote="$(git remote -v | awk '/^origin.*\(push\)$/ {print $2}')"
	[[ "$remote" ]] || return
	local user_repo="$(echo "$remote" | perl -pe 's/.*://;s/\.git$//')"
	git log $* --name-status --color | awk "$(cat <<AWK
		/^.*commit [0-9a-f]{40}/ {sha=substr(\$2,1,7)}
		/^[MA]\t/ {printf "%s\thttps://github.com/$user_repo/blob/%s/%s\n", \$1, sha, \$2; next}
		/.*/ {print \$0}
AWK
	)" | less -F
}

# Copy w/ progress
cp_p () {
	rsync -WavP --human-readable --progress $1 $2
}

sshSecureKeygen() {
	ssh-keygen -b 4096 -f ~/.ssh/id_rsa_$1 -C sam@$1_4096
}

# Syntax-highlight JSON strings or files
function json() {
	if [ -p /dev/stdin ]; then
		# piping, e.g. `echo '{"foo":42}' | json`
		python -mjson.tool | pygmentize -l javascript
	else
		# e.g. `json '{"foo":42}'`
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	fi
}

# take this repo and copy it to somewhere else minus the .git stuff.
function gitexport(){
	mkdir -p "$1"
	git archive master | tar -x -C "$1"
}

# get gzipped size
function gz() {
	echo "orig size    (bytes): "
	cat "$1" | wc -c
	echo "gzipped size (bytes): "
	gzip -c "$1" | wc -c
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
	if [ -f "$1" ] ; then
		local filename=$(basename "$1")
		local foldername="${filename%%.*}"
		local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
		local didfolderexist=false
		if [ -d "$foldername" ]; then
			didfolderexist=true
			read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
			echo
			if [[ $REPLY =~ ^[Nn]$ ]]; then
				return
			fi
		fi
		mkdir -p "$foldername" && cd "$foldername"
		case $1 in
			*.tar.bz2) tar xjf "$fullpath" ;;
			*.tar.gz) tar xzf "$fullpath" ;;
			*.tar.xz) tar Jxvf "$fullpath" ;;
			*.tar.Z) tar xzf "$fullpath" ;;
			*.tar) tar xf "$fullpath" ;;
			*.taz) tar xzf "$fullpath" ;;
			*.tb2) tar xjf "$fullpath" ;;
			*.tbz) tar xjf "$fullpath" ;;
			*.tbz2) tar xjf "$fullpath" ;;
			*.tgz) tar xzf "$fullpath" ;;
			*.txz) tar Jxvf "$fullpath" ;;
			*.zip) unzip "$fullpath" ;;
			*) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

# packs $2-$n into $1 depending on $1's extension.  add more file types as needed
function pack() {
	if [ $# -lt 2 ] ; then
		echo -e "\npack() usage:"
		echo -e "\tpack archive_file_name file1 file2 ... fileN"
		echo -e "\tcreates archive of files 1-N\n"
	else
		DEST=$1
		shift

		case $DEST in
			*.tar.bz2) tar -cvjf $DEST "$@" ;;
			*.tar.gz) tar -cvzf $DEST "$@" ;;
			*.zip) zip -r $DEST "$@" ;;
			*.xpi) zip -r $DEST "$@" ;;
			*) echo "Unknown file type - $DEST" ;;
		esac
	fi
}

# change the version of java being used on the fly
function setjdk() {
	export JAVA_HOME=$(/usr/libexec/java_home -v $1)
}

function update() {
	if [[ "$OSTYPE" =~ darwin ]]; then
		# Get OS X Software Updates
		sudo softwareupdate -i -a
	elif [[ "$OSTYPE" =~ linux-gnu ]]; then
		if hash apt-get 2> /dev/null; then
			sudo apt-get -y update
		elif hash yum 2> /dev/null; then
			sudo yum -y update
		fi
	fi

	# Homebrew
	brew update
	brew upgrade
	brew cleanup

	# Node modules
	npm update npm -g
	npm update -g

	# Ruby gems
	gem update
}
